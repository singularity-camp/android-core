<h1>Лямбды</h1>

<p>Лямбда-выражения представляют небольшие кусочки кода, которые выполняют некоторые действия. Фактически лямбды преставляют сокращенную запись функций. При этом лямбды, как и обычные и анонимные функции, могут передаваться в качестве значений переменным и параметрам функции.</p>

<p>Лямбда-выражения оборачиваются в фигурные скобки:</p>

<pre><code>{println("Hello, Guys!")}</code></pre>

<p>Лямбда-выражение можно сохранить в обычную переменную и затем вызывать через имя этой переменной как обычную функцию:</p>

<pre><code>fun main() {
    val hello = {println("Hello, Students")}
    hello()
    hello()
}</code></pre>

<p> В данном случае лямбда сохранена в переменную hello и через эту переменную вызывается два раза. Поскольку лямбда-выражение представляет сокращенную форму функции, то переменная <code>hello</code> имеет тип функции <code>() -&gt; Unit</code>:</p>

<pre><code>val hello: ()-&gt;Unit = {println("Hello again!")}</code></pre>

<p>Также лямбда-выражение можно запускать как обычную функцию, используя круглые скобки:</p>

<pre><code>fun main() {
    {println("and again :)")}()
}</code></pre>

<h3>Передача параметров</h3>

<p>Лямбды как и функции могут принимать параметры. Для передачи параметров используется стрелка -&gt;. Параметры указываются слева от стрелки, а тело лямбда-выражения, то есть сами выполняемые действия, справа от стрелки.</p>

<pre><code>fun main() {
    val printer = {message: String -&gt; println(message)}
    printer("Another greating")
    printer("One more time")
}</code></pre>

<p>Здесь лямбда-выражение принимает один параметр типа String, значение которого выводится на консоль. Переменная <code>printer</code> в данном случае имеет тип <code>(String) -&gt; Unit</code>.</p>

<p>Если параметров несколько, то они передаются слева от стрелки через запятую:</p>

<pre><code>fun main() {
    val sum = {x:Int, y:Int -&gt; println(x + y)}
    sum(2, 3)   // 5
    sum(4, 5)   // 9
}</code></pre>

<p>Если в лямбда-выражении надо выполнить не одно, а несколько действий, то эти действия можно размещать на отдельных строках после стрелки:</p>

<pre><code>val sum = {x:Int, y:Int -&gt;
    val result = x + y
    println("$x + $y = $result")
}</code></pre>

<h2>Возвращение результата</h2>

<p>Выражение, стоящее после стрелки, определяет результат лямбда-выражения. И этот результат мы можем присвоить, например, переменной.</p>

<p>Если лямбда-выражение формально не возвращает никакого результата, то фактически, как и в функциях, возвращается значение типа <code>Unit</code>:</p>

<pre><code>val hello = { println("Hi!")}
val h = hello()             // h представляет тип Unit
 
val printer = {message: String -&gt; println(message)}
val p = printer("Bye!")    // p представляет тип Unit</code></pre>

<p>В обоих случаях используется функция println, которая формально не возвращает никакого значения (точнее возвращает объект типа <code>Unit</code>).</p>

<p>Но также может возвращаться конкретное значение:</p>

<pre><code>fun main() {
    val product = {x:Int, y:Int -&gt; x * y}
     
    val a = product(2, 3)   // 5
    val b = product(4, 5)   // 9
}</code></pre>

<p>Здесь выражение справа от стрелки <code>x + y</code> продуцирует новое значение - сумму чисел, и при вызове лямбда-выражения это значение можно передать переменной. В данном случае лямбда-выражение имеет тип <code>(Int, Int) -&gt; Int</code>.</p>

<p>Если лямбда-выражение многострочное, состоит из нескольких инструкций, то возвращается то значение, которое генерируется последней инструкцией:</p>

<pre><code>val product = {x:Int, y:Int -&gt;
    val result = x * y
    println("$x * $y = $result")
    result
}</code></pre>

<p>Последнее выражение по сути представляет число - сумму чисел x и y и оно будет возвращаться в качестве результата лямбда-выражения.</p>






<h1>Лямбда-выражения как аргументы функций</h1>

<p>Лямбда-выражения можно передавать параметрам функции, если они представляют один и тот же тип функции:</p>

<pre><code>fun main() {
    val product = {x:Int, y:Int -&gt; x * y }
    doOperation(3, 4, sum)                      // 12
    doOperation(3, 4, {a:Int, b: Int -&gt; a + b}) // 7
 
}
fun doOperation(x: Int, y: Int, op: (Int, Int) -&gt;Int){
    val result = op(x, y)
    println(result)
}</code></pre>

<h2>Trailing lambda</h2>

<p>Если параметр, который принимает функцию, является последним в списке, то при передачи ему лямбда-выражения, саму лямбду можно прописать после списка параметров. Например, возьмем выше использованную функцию <code>doOperation()</code>:</p>

<pre><code>fun doOperation(x: Int, y: Int, op: (Int, Int) -&gt;Int){
    val result = op(x, y)
    println(result)
}</code></pre>

<p>Здесь параметр, который представляет функцию - параметр <code>op</code>, является последним в списке параметров. Поэтому вместо того, чтобы написать так:</p>

<p><code>doOperation(3, 4, {a, b -&gt; a * b}) </code><code>// 1</code></p>

<p>Мы также можем написать так:</p>

<p><code>doOperation(3, 4) {a, b -&gt; a * b} </code><code>// 12</code></p>

<p>То есть вынести лямбду за список параметров. Это так называемая конечная лямбда или <strong>trailing lambda</strong></p>

<h2>Возвращение лямбда-выражения из функции</h2>

<p>Также фукция может возвращать лямбда-выражение, которое соответствует типу ее возвращаемого результата:</p>

<pre><code>fun main() {
    val action1 = selectAction(1)
    val result1 = action1(4, 5)
    println(result1)        // 9
 
    val action2 = selectAction(3)
    val result2 = action2(4, 5)
    println(result2)        // 20
 
    val action3 = selectAction(9)
    val result3 = action3(4, 5)
    println(result3)        // 0
}
fun selectAction(key: Int): (Int, Int) -&gt; Int{
    // определение возвращаемого результата
    when(key){
        1 -&gt; return {x, y -&gt; x + y }
        2 -&gt; return {x, y -&gt; x - y }
        3 -&gt; return {x, y -&gt; x * y }
        else -&gt; return {x, y -&gt; 0 }
    }
}</code></pre>



