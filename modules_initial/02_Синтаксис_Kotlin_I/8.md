<h1>Операции</h1>

<p>Котлин поддерживает стандартный набор арифметических операций над числами: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>. Они объявляются членами соответствующих классов.</p>

<pre><code>println(1 + 2)
println(2_500_000_000L - 1L)
println(3.14 * 2.71)
println(10.0 / 3)
</code></pre>

<p>Вы также можете переопределить эти операторы для пользовательских классов.</p>



<h1> Деление целых чисел</h1>

<p>Деление целых чисел всегда возвращат целое число. Любая дробная часть отбрасывается.</p>

<pre><code>val x = 5 / 2
// println(x == 2.5) // ОШИБКА: Оператор '==' не может быть применен к 'Int' и 'Double'
println(x == 2) // true
</code></pre>

<p>Это справедливо для деления любых двух целочисленных типов.</p>

<pre><code>val x = 5L / 2
println(x == 2L) // true
</code></pre>

<p>Чтобы вернуть тип с плавающей точкой, явно преобразуйте один из аргументов в тип с плавающей точкой.</p>

<pre><code>val x = 5 / 2.toDouble()
println(x == 2.5) // true
</code></pre>


<h1>Побитовые операции</h1>

<p>Kotlin поддерживает обычный набор <em>побитовых операций</em> над целыми числами. Они работают на двоичном уровне непосредственно с битовыми представлениями чисел. Побитовые операции представлены функциями, которые могут быть вызваны в инфиксной форме. Они могут быть применены только к <code>Int</code> и <code>Long</code>.</p>

<pre><code>val x = (1 shl 2) and 0x000FF000
</code></pre>

<p>Ниже приведён полный список битовых операций:</p>

<ul>
	<li><code>shl(bits)</code> – сдвиг влево с учётом знака (<code>&lt;&lt;</code> в Java)</li>
	<li><code>shr(bits)</code> – сдвиг вправо с учётом знака (<code>&gt;&gt;</code> в Java)</li>
	<li><code>ushr(bits)</code> – сдвиг вправо без учёта знака (<code>&gt;&gt;&gt;</code> в Java)</li>
	<li><code>and(bits)</code> – побитовое И</li>
	<li><code>or(bits)</code> – побитовое ИЛИ</li>
	<li><code>xor(bits)</code> – побитовое исключающее ИЛИ</li>
	<li><code>inv()</code> – побитовое отрицание</li>
</ul>



<h1>Сравнение чисел с плавающей точкой</h1>

<p>В этом разделе обсуждаются следующие операции над числами с плавающей запятой:</p>

<ul>
	<li>Проверки на равенство: <code>a == b</code> и <code>a != b</code></li>
	<li>Операторы сравнения: <code>a &lt; b</code>, <code>a &gt; b</code>, <code>a &lt;= b</code>, <code>a &gt;= b</code></li>
	<li>Создание диапазона и проверка диапазона: <code>a..b</code>, <code>x in a..b</code>, <code>x !in a..b</code></li>
</ul>

<pre><code>val a = 10
val b = 12
if(a &lt; b) {
    println("a меньше b")
}else {
    println("b меньше a")
}</code></pre>

<p>Когда статически известно, что операнды <code>a</code> и <code>b</code> являются <code>Float</code> или <code>Double</code> или их аналогами с nullable-значением (тип объявлен или является результатом <a href="https://kotlinlang.ru/docs/typecasts.html#smart-casts" rel="noopener noreferrer nofollow">умного приведения</a>), операции с числами и диапазоном, который они образуют, соответствуют стандарту <a href="https://en.wikipedia.org/wiki/IEEE_754" rel="noopener noreferrer nofollow">IEEE 754 для арифметики с плавающей точкой</a>.</p>

<p>Однако для поддержки общих вариантов использования и обеспечения полного упорядочивания, когда операнды статически <em>не</em> объявлены как числа с плавающей запятой (например, <code>Any</code>, <code>Comparable&lt;...&gt;</code>, параметр типа), операции используют реализации <code>equals</code> и <code>compareTo</code> для <code>Float</code> и <code>Double</code>, которые не согласуются со стандартом, так что:</p>

<ul>
	<li><code>NaN</code> считается равным самому себе</li>
	<li><code>NaN</code> считается больше, чем любой другой элемент, включая "POSITIVE_INFINITY"</li>
	<li><code>-0.0</code> считается меньше, чем <code>0.0</code></li>
</ul>



<h1>Задача</h1>

<p>Создать программу, проверяющую и сообщающую на экран, является ли целое число записанное в переменную n, чётным либо нечётным.</p>

<p>Четные - print(true)</p>

<p>Не четные - print(false)</p>
