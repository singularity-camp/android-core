<h1>О жизненном цикле Activity</h1>

<p>Приложения, которые мы пишем, имеют определенный жизненный цикл. После запуска <code>activity</code> проходит через события, которые обрабатываются системой:</p>

<ol>
	<li><strong>override fun<strong> onCreate(Bundle saveInstanceState);</strong></strong></li>
	<li><strong>override fun <strong>onStart();</strong></strong></li>
	<li><strong>override fun <strong>onRestart(); (опционально)</strong></strong></li>
	<li><strong>override fun <strong>onResume();</strong></strong></li>
	<li><strong>override fun <strong>onPause();</strong></strong></li>
	<li><strong>override fun <strong>onStop();</strong></strong></li>
	<li><strong>override fun <strong>onDestroy();</strong></strong></li>
</ol>

<p>Схематично взаимосвязь между всеми этими обратными вызовами можно представить следующим образом:</p>

<p style="text-align: center;"><img alt="" height="666" name="image.png" src="https://ucarecdn.com/f325296d-6a1b-4fef-9420-1517bdbe61e3/" width="519"></p>




<h1>Подробнее об методах ЖЦ Activity</h1>

<h3>onCreate()</h3>

<p>Это первый метод, с которого начинается выполнение activity. <code>Activity</code> переходит в состояние <strong>created</strong>. Этот метод получает объект <code>Bundle</code>, который содержит <strong>прежнее состояние activity</strong>, если оно было сохранено. Но также объект может быть и null, что будет означать, что данное activity не было пересоздано. Если же <code>activity</code> уже ранее была создана, то <strong>bundle</strong> содержит связанную с <code>activity</code> информацию.</p>

<h3>onStart</h3>

<p>В это методе осуществляется подготовка к выводу activity на экран устройства. Не всегда этот метод требует переопределения, так как бОльшая часть инициализаций произошла уже в <strong>onCreate()</strong>. После завершения работы метода <code>activity</code> отображается на экране, вызывается метод <code>onResume.</code></p>

<h3>onResume</h3>

<p>При вызове метода <code>onResume</code> отображается на экране устройства, и пользователь может с ней взаимодействовать. <code>Activity</code> остается в этом состоянии, пока она не потеряет фокус, например, в следствии переключения на другую <code>activity</code> или просто из-за выключения экрана устройства.</p>

<h3>onPause</h3>

<p>Если пользователь решит перейти к другой activity, то система вызывает метод <code>onPause</code>, а activity переходит в состояние <strong>Paused</strong>. В этом методе можно освобождать используемые ресурсы, приостанавливать процессы, например, воспроизведение аудио, анимаций, останавливать работу камеры (если она используется) и т.д., чтобы они меньше сказывались на производительность системы.</p>

<p>Но надо учитывать, что в этом состоянии activity по прежнему остается видимой на экране, и на работу данного метода отводится очень мало времени, поэтому не стоит здесь сохранять какие-то данные, особенно если при этом требуется обращение к сети, например, отправка данных по интернету, или обращение к базе данных - подобные действия лучше выполнять в методе <code>onStop()</code>.</p>

<p>После выполнения этого метода activity становится невидимой, не отображается на экране, но она все еще активна. И если пользователь решит вернуться к этой activity, то система вызовет снова метод <code>onResume</code>, и activity снова появится на экране.</p>

<p>Другой вариант работы может возникнуть, если вдруг система видит, что для работы активных приложений необходимо больше памяти. И система может сама завершить полностью работу activity, которая невидима и находится в фоне. Либо пользователь может нажать на кнопку Back (Назад). В этом случае у activity вызывается метод onStop.</p>

<h3>onStop</h3>

<p>В этом состоянии <code>activity</code> полностью невидима. Здест следует освобождать используемые ресурсы, которые не нужны пользователю, когда он не взаимодействует с <code>activity</code>. Здесь также можно сохранять данные, например, в базу данных.</p>

<p>Стоит отметить, что в данном состоянии <code>activity</code> остается в памяти устройства, то есть сохраняется состояние всех элементов интерфейса. К примеру, если в текстовое поле <code>EditText</code> был введен какой-то текст, то после возобновления работы <code>activity</code> и перехода ее в состояние <strong>Resumed</strong> мы вновь увидим в текстовом поле ранее введенный текст.</p>

<h3>onDestroy</h3>

<p>Завершается работа <code>activity</code> вызовом метода <code>onDestroy</code>, который возникает либо, если система решит убить <code>activity</code> в силу конфигурационных причин (поговорим об это позже), либо при вызове метода <code>finish()</code>.</p>

<p>В целом переход между состояниями activity можно выразить следующей схемой:</p>

<p style="text-align: center;"><img alt="" height="342" name="image.png" src="https://ucarecdn.com/e7076941-de3d-4493-b7fd-40578f42e7ff/" width="798"></p>




<h1>Почему важно понимать работу ЖЦ?</h1>

<p>В андроид многие компоненты имеют свой жизненный цикл. Так, помимо <code>Activity</code>, ЖЦ есть у <code>View</code>, <code>Fragment</code>-ов и сервисов, о которых мы поговорим позже в рамках курса.</p>

<p>Понимание жизненного цикла и правильная реакция на изменения его состояния имеют решающее значение. Он позволяет создавать приложения с меньшим количеством ошибок, использовать меньше системных ресурсов Android и обеспечивать хорошее взаимодействие с пользователем. Вдобавок, вопрос про ЖЦ activity является одним из первых на технических собеседованиях :) </p>

<p>Официальная документация:</p>

<p><a href="https://developer.android.com/guide/components/activities/activity-lifecycle" rel="noopener noreferrer nofollow">https://developer.android.com/guide/components/activities/activity-lifecycle</a></p>
