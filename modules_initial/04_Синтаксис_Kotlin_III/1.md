<h1>Классы</h1>

<p>В Kotlin классы объявляются с помощью использования ключевого слова <code>class</code>.</p>

<pre><code>class Jusan { 
   // Тело класса
}
</code></pre>

<p>Класс состоит из имени класса, заголовка (указания типов его параметров, основного конструктора и т.п) и тела класса, состоящая из фигурных скобок. И заголовок, и тело класса являются необязательными составляющими. Если у класса нет тела, фигурные скобки могут быть опущены.</p>

<pre><code>class Jusan
</code></pre>





<h1>Конструкторы</h1>

<p>Класс в Kotlin может иметь <em>основной конструктор</em> (<em>primary constructor</em>) и один или более <em>дополнительных конструкторов</em> (<em>secondary constructors</em>). Основной конструктор является частью заголовка класса, его объявление идёт сразу после имени класса (и необязательных параметров).</p>

<pre><code>class Jusan constructor(firstName: String) {
    // Тело класса
}
</code></pre>

<p>Если у основного конструктора нет аннотаций и модификаторов видимости, ключевое слово <code>constructor</code> может быть опущено.</p>

<pre><code>class Jusan(firstName: String) { /*...*/ }
</code></pre>

<p>Основной конструктор не может содержать в себе исполняемого кода. Инициализирующий код может быть помещён в соответствующие блоки (<em>initializers blocks</em>), которые помечаются словом <code>init</code>.</p>

<p>При создании экземпляра класса блоки инициализации выполняются в том порядке, в котором они идут в теле класса, чередуясь с инициализацией свойств.</p>

<pre><code>class InitOrderDemo(name: String) {
    val firstProperty = "Первое свойство: $name".also(::println)
    
    init {
        println("Первый блок инициализации: ${name}")
    }
    
    val secondProperty = "Второе свойство: ${name.length}".also(::println)
    
    init {
        println("Второй блок инициализации: ${name.length}")
    }
}
</code></pre>

<p>Обратите внимание, что параметры основного конструктора могут быть использованы в инициализирующем блоке. Они также могут быть использованы при инициализации свойств в теле класса.</p>

<pre><code>class Jusan(name: String) {
    val customerKey = name.uppercase()
}
</code></pre>

<p>Для объявления и инициализации свойств основного конструктора в Kotlin есть лаконичное синтаксическое решение:</p>

<pre><code>class Jusan(val firstName: String, val lastName: String, var age: Int)
</code></pre>

<p>Такие объявления также могут включать в себя значения свойств класса по умолчанию.</p>

<pre><code>class Jusan(val firstName: String, val lastName: String, var isEmployed: Boolean = true)
</code></pre>

<p>Вы можете использовать завершающую запятую при объявлении свойств класса.</p>

<pre><code>class Jusan(
    val firstName: String,
    val lastName: String,
    var age: Int, // завершающая запятая
) { /*...*/ }
</code></pre>

<p>Свойства, объявленные в основном конструкторе, могут быть изменяемые (<code>var</code>) и неизменяемые (<code>val</code>).</p>

<p>Если у конструктора есть аннотации или модификаторы видимости, ключевое слово <code>constructor</code> обязательно, и модификаторы используются перед ним.</p>

<pre><code>class Jusan public @Inject constructor(name: String) { /*...*/ }
</code></pre>



<h1>Дополнительные конструкторы</h1>

<p>В классах также могут быть объявлены <em>дополнительные конструкторы</em> (<em>secondary constructors</em>), перед которыми используется ключевое слово <code>constructor</code>.</p>

<pre><code>class Person(val pets: MutableList&lt;Pet&gt; = mutableListOf())
class Pet {
    constructor(owner: Person) {
        owner.pets.add(this) // добавляет выбранного питомца в список домашних животных своего владельца
    }
}
</code></pre>

<p>Если у класса есть основной конструктор, каждый дополнительный конструктор должен прямо или косвенно ссылаться (через другой(<em>ие</em>) конструктор(<em>ы</em>)) на основной. Осуществляется это при помощи ключевого слова <code>this</code>.</p>

<pre><code>class Person(val name: String) {
    val children: MutableList&lt;Person&gt; = mutableListOf()
    constructor(name: String, parent: Person) : this(name) {
        parent.children.add(this)
    }
}
</code></pre>

<p>Обратите внимание, что код в блоках инициализации фактически становится частью основного конструктора. Дополнительный конструктор ссылается на основной при помощи своего первого оператора, поэтому код во всех блоках инициализации, а также инициализация свойств выполняется перед выполнением кода в теле дополнительного конструктора.</p>

<p>Даже если у класса нет основного конструктора на него все равно происходит неявная ссылка и блоки инициализации выполняются также.</p>

<pre><code>class Constructors {
    init {
        println("Блок инициализации")
    }
    constructor(i: Int) {
        println("Constructor $i")
    }
}
</code></pre>

<p>Если в абстрактном классе не объявлено никаких конструкторов (основного или дополнительных), у этого класса автоматически сгенерируется пустой конструктор без параметров. Видимость этого конструктора будет public.</p>

<p>Если вы не желаете иметь класс с открытым <em>public</em> конструктором, вам необходимо объявить пустой конструктор с соответствующим модификатором видимости.</p>

<pre><code>class DontCreateMe private constructor () { /*...*/ }
</code></pre>

<blockquote>
<p>В JVM компилятор генерирует дополнительный конструктор без параметров в случае, если все параметры основного конструктора имеют значения по умолчанию. Это делает использование таких библиотек, как Jackson и JPA, более простым с Kotlin, так как они используют пустые конструкторы при создании экземпляров классов.</p>

<pre><code>class Customer(val customerName: String = "")
</code></pre>
</blockquote>




<h1>Создание экземпляров классов</h1>

<p>Для создания экземпляра класса конструктор вызывается так, как если бы он был обычной функцией.</p>

<pre><code>val invoice = Invoice()

val customer = Customer("Петр Ян")
</code></pre>

<blockquote>
<p>В Kotlin нет ключевого слова <code>new</code>.</p>
</blockquote>




