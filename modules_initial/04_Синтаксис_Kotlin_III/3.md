<h1>Интерфейсы</h1>

<p>Интерфейсы в Kotlin могут содержать объявления абстрактных методов, а также методы с реализацией. Главное отличие интерфейсов от абстрактных классов заключается в невозможности хранения переменных экземпляров. Они могут иметь свойства, но те должны быть либо абстрактными, либо предоставлять реализацию методов доступа.</p>

<p>Интерфейс определяется ключевым словом <code>interface</code>.</p>

<pre><code>interface MyInterface {
    fun bar()
    fun foo() {
      // тело можно не писать
    }
}</code></pre>





<h2>Реализация интерфейсов</h2>

<p>Класс или объект могут реализовать любое количество интерфейсов.</p>

<pre><code>class Child : MyInterface {
    override fun bar() {
        // должны реализовать тело
    }
}</code></pre>





<h2>Свойства в интерфейсах</h2>

<p>Вы можете объявлять свойства в интерфейсах. Свойство, объявленное в интерфейсе, может быть либо абстрактным, либо иметь свою реализацию методов доступа. Свойства в интерфейсах не могут иметь теневых полей, соответственно, методы доступа к таким свойствам не могут обращаться к теневым полям.</p>

<pre><code>interface MyInterface {
    val prop: Int // абстрактное свойство

    val propertyWithImplementation: String
        get() = "brr"

    fun foo() {
        print(prop)
    }
}

class Child : MyInterface {
    override val prop: Int = 22
}</code></pre>






<h2>Свойства в интерфейсах</h2>

<p>Вы можете объявлять свойства в интерфейсах. Свойство, объявленное в интерфейсе, может быть либо абстрактным, либо иметь свою реализацию методов доступа. Свойства в интерфейсах не могут иметь теневых полей, соответственно, методы доступа к таким свойствам не могут обращаться к теневым полям.</p>

<pre><code>interface MyInterface {
    val prop: Int // абстрактное свойство

    val propertyWithImplementation: String
        get() = "brr"

    fun foo() {
        print(prop)
    }
}

class Child : MyInterface {
    override val prop: Int = 22
}</code></pre>




<h2>Устранение противоречий при переопределении</h2>

<p>Когда мы объявлем большое количество типов в списке нашего супертипа, может так выйти, что мы допустим более одной реализации одного и того же метода.</p>

<pre><code>interface A {
    fun foo() { print("A") }
    fun bar()
}

interface B {
    fun foo() { print("B") }
    fun bar() { print("bar") }
}

class C : A {
    override fun bar() { print("bar") }
}

class D : A, B {
    override fun foo() {
        super&lt;A&gt;.foo()
        super&lt;B&gt;.foo()
    }
    
    override fun bar() {
        super&lt;B&gt;.bar()
    }
}
</code></pre>

<p>Оба интерфейса <em>A</em> и <em>B</em> объявляют функции <code>foo()</code> и <code>bar()</code>. Оба реализуют <code>foo()</code>, но только <em>B</em> содержит реализацию <code>bar()</code> (<code>bar()</code> не отмечен как абстрактный метод в интерфейсе <em>A</em>, потому что в интерфейсах это подразумевается по умолчанию, если у функции нет тела). Теперь, если вы унаследуете какой-нибудь класс <em>C</em> от интерфейса <em>A</em>, вам, очевидно, придётся переопределять метод <code>bar()</code>, обеспечивая его реализацию.</p>

<p>Однако если вы унаследуете класс <em>D</em> от интерфейсов <em>A</em> и <em>B</em>, вам надо будет переопределять все методы, которые вы унаследовали от этих интерфейсов, и вам нужно указать, как именно <em>D</em> должен их реализовать. Это правило касается как тех методов, у которых имеется только одна реализация (<code>bar()</code>), так и тех, у которых есть несколько реализаций (<code>foo()</code>).</p>







