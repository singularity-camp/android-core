<h1>Корутины</h1>

<p>Как уже мы повторяли ранее, создание и управление потоками дело сложное с точки зрения ресурсов. К тому же инструменты, которые предоставляют интерфейсы для работы с потоками имеют свои недостатки. Котлин предоставляет эффективный инструмент - Coroutines.&nbsp;</p>

<p>Основные плюсы корутин:</p>

<ul>
	<li>Легкость использования. Везде дается определение корутин как &quot;легковесные потоки&quot;. Почему это на самом деле так, мы разберем позже.</li>
	<li>Легкость написания. Корутины позволяют писать асинхронный код в синхронном стиле! Это здорово упрощает чтение и понимание кода.&nbsp;</li>
	<li>Coroutines - фича Kotlin. То есть помимо всех плюсов языка мы получается независимость от платформы, на которой этот код запускается. (Помимо аппаратных ограничений, конечно же)</li>
</ul>

<pre>
<code>//Вместо 
fetchNetworkData(
        onStart = {
            showLoader()
        },
        onFinish = {
            hideLoader()
        },
        onError {
            handleError()
        },
        onComplete { networkData -&gt;
            val networkDetails = networkData.getDetails()
            fetchNewDetails(networkDetails)
        }
)
//Мы пишем:
suspend fun fetchNetworkData() {
        try {
            showLoader()
            hideLoader()
            val networkDetails = networkData.getDetails()
            fetchNewDetails(networkDetails)
        } catch(e: Exception) {
            handleError()
        }
    }</code></pre>



<h1>Что такое корутины</h1>

<p>"Легковесные потоки". На этом у нас все, всем спасибо.</p>

<p>Нет, не так просто...</p>

<p>Хотя работа корутин напрямую связана с потоками, они не про многопоточность, а про асинхронность. Потоками являются инструменты, которыми эффективно пользуются корутины. К примеру, создадим <strong>миллион</strong> потоков:</p>

<pre><code>@OptIn(ExperimentalTime::class)
fun main(args: Array&lt;String&gt;) {
    val time: Duration = measureTime {
        repeat(1_000_000) {
            Thread {
                println("Hi from thread")
            }.start()
        }
    }

    println("Finished in ${time.inWholeSeconds} seconds")
}</code></pre>

<p>Вывод получился таким:</p>

<p><img alt="" height="400" name="image.png" src="https://ucarecdn.com/78a1fe52-9746-41be-95d2-bda093e28e6c/" width="480"></p>

<p>Теперь создадим <strong>миллион</strong> корутин. Как именно они создаются мы разберем позже.</p>

<pre><code>fun main(args: Array&lt;String&gt;) = runBlocking {
    repeat(1_000_000) {
        launch { // запуск корутины
            println("Hi from thread")
        }
    }
}</code></pre>

<p>Угадаете за сколько отработал код? Чтобы добавить логирование, нужно немного повозиться:</p>

<pre><code>@OptIn(ExperimentalTime::class)
fun main(args: Array&lt;String&gt;) = runBlocking {
    val time: Duration = measureTime {
        launch { // корутина для измерения времени
            repeat(1_000_000) {
                launch {
                    println("Hi from thread")
                }
            }
        }.join()
    }
    println("Finished in ${time.inWholeMilliseconds} ms")
}</code></pre>

<p><img alt="" height="292" name="image.png" src="https://ucarecdn.com/f99f8cc4-9ae2-44f7-bdb8-004005946f8d/" width="690"></p>

<p><strong>1.2 секунды!!!</strong></p>

<p>Разница ощутимая, однако в коде выше запускалась лишняя корутина для высчитывать времени, так что смею округлить до 1.1 секунд.</p>


<h1>Threads vs Coroutines</h1>

<p>Запустите пример ниже:</p>

<pre><code>@OptIn(ExperimentalTime::class)
fun main(args: Array&lt;String&gt;) {
    measureTime {
        repeat(10) {
            Thread {
                println("Hi from ${Thread.currentThread().name}")
            }.start()
        }
    }
}</code></pre>

<p>Код запускает 10 потоков и выводит название потока. О чем вам говорит названия в консоли?</p>

<p>Теперь запустим корутины и проверим имена потоков:</p>

<pre><code>fun main(args: Array&lt;String&gt;) = runBlocking {
    repeat(10) {
        launch {
            println("Hi from ${Thread.currentThread().name}")
        }
    }
}</code></pre>

<p>Как видите все корутины запускаются в одном потоке, причем в главном. Никаких усилий для создания потоков, смену потоков и уничтожения не применялось, по этой причине и код отработал быстрее. Причем, чем больше корутин используется для работы вместо потоков, тем больше разницы по времени выполнения и требуемых ресурсах мы можем получить. </p>

<p>Дело в том, что корутины используют потоки эффективно:</p>

<p style="text-align: center;"><img alt="" height="329" name="image.png" src="https://ucarecdn.com/28afad7c-6a54-4574-aacd-01b451664fa1/" width="571"></p>

<p>Как видно на картинке выше, при ожидании завершения долгой операции (запрос в сеть, бд, обработка фото) текущий поток блокируется, а значит и ресурсы в этом потоке недоступны для какой-либо работы.После завершения долгой операции поток и его ресурсы разблокируются и флоу идет дальше. Корутины <strong>не блокируют</strong> работу потока. Они <strong>приостанавливают</strong> свою работу, ожидая завершения операции, а когда операция, которую ждет корутина завершится, продолжат свою работу (но не обязательно в том потоке, в котором были изначально).</p>




<h1>Создание корутины</h1>

<p>Создание корутин происходит с помощью <strong>Coroutine Builder</strong>-ов.</p>

<p>В прошлом разделе мы использовали конструкцию <strong>runBlocking</strong>. Она предназначена для соединения привычного нам кода с корутинами. </p>

<pre><code>fun main(args: Array&lt;String&gt;) = runBlocking {
    delay(5_000L)
}</code></pre>

<p>В примере выше весь блок main будет <strong>блокировать </strong>поток, в котором он выполняется, пока весь код внутри coroutine builder-a не закончит свое выполнение. Такая конструкция используется в методах main, однако в мире андроид такого метода у нас нет. Также <strong>runBlocking</strong> используется при написании тестов и это, пожалуй,  единственное место, где его стоит использовать в Андроид разработке, так как блокирование потока не хорошая практика. </p>

<p>Также в прошлых примерах использался <strong>launch</strong> {}. Это также является builder-ом, причем самым популярным:</p>

<pre><code>fun main(args: Array&lt;String&gt;): Unit = runBlocking {
    launch {
        delay(5_000L)
        println("This is launch builder")
        delay(1_000L)
        println("End of Builder")
    }
}</code></pre>

<p>Здесь нам пришлось явно указать return type у main, так как <strong>runBlocking</strong> возвращает то, что вернет код внутри блока, а <strong>launch</strong> в свою очередь вернет <code>Job</code>. Об этом поговорим позже, а пока можно просто явно указать <code>Unit</code> как return type и позволить запустить программу. </p>

<p>Метод "delay()" приостанавливает выполнение корутины на заданный в аргументах период времени. Обратите внимание, что код в блоке launch выполняем <strong>последовательно</strong>. Delay приостановил выполнение корутины на 5 секунд, так как метод <strong>delay()</strong> помечен ключевым словом <u><strong>suspend</strong></u>. Помеченный таким образом метод может вызываться только из корутины, либо из другого метода <u><strong>suspend</strong></u>. Само обозначение дает понимать, что операция внутри (либо вызов другого <strong>suspend</strong> метода) будет приостанавливать выполнение корутины, из которой вызывался этот <strong>suspend</strong> метод. Подробнее про <strong>suspend</strong> поговорим позже в этом уроке.</p>

<p>Также есть еще один coroutine builder - <strong>async()</strong>. Он используется для паралельного выполнения корутин. Об этом мы поговорим в следующем уроке. </p>


<h1>Coroutine Scope</h1>

<p>Корутины (последовательные/параллельные) выполняются асинхронно и завершаются в зависимости от того, какой код выполнятся внутри корутины. В таких случаях код может продолжать выполняться, даже если вызывающий корутину код уже завершился. Если корутину не остановить при остановки вызывающей стороны, это может привести к нежелательным последствиям (утечке памяти, например).</p>

<p>Для такого контроля жизненного цикла корутин был придуман <strong>Coroutine Scope</strong>.Он позволяет контролировать жизненный цикл корутины и всех <strong>suspend</strong> методов внутри, в том числе дочерних корутин. Мы связываем выполнение какой-то корутины с ЖЦ этого scope и при надобности можем остановить выполнение всех корутин в рамках этого скоупа. </p>

<pre><code>fun main(args: Array&lt;String&gt;) {
    val job = GlobalScope.launch {
        delay(1000L)
        println("After 1s")
        delay(1000L)
        println("After 2s")
        delay(1000L)
        println("After 3s")
        delay(1000L)
        println("After 4s")
    }

    Thread.sleep(2500L)
    println("Cancelling after 2.5s")
    job.cancel()
    Thread.sleep(2000L)
}</code></pre>

<p>В примере выше создается корутина с <code>GlobalScope</code>, результат в виде <code>Job</code> записывается в переменную. После 2.5 секунд останавливаем job, и как видно из вывода на консоли, корутина останавливается. </p>

<p><code>GlobalScope</code> сам по себе не привязан ни к чему. Его необходимо останавливать ручками, из-за чего не рекомендуется к использованию. В будущем уроке мы напишем свой <code>Scope</code>, который будет останавливаться автоматически при закрытии экрана. </p>

<p>Обратите внимание в коде выше мы не используем <code>runBlocking</code>. Текущий поток останавливается с помощью Thread.sleep, после чего останавливается корутина и за последние 2 секунд консоль не отобразила вывод из под корутины.</p>


