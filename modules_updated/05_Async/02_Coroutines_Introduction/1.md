<h1>Потоки</h1>

<p>Часто нам нужно в приложениях производить долгие операции - сходить в сеть за списком деталей для отображения, произвести сложные расчеты, сохранить большое количество данных в файл и. т. д. Представим, что нам надо сходить в сеть и отобразить результат:</p>

<pre><code>fun loadData() {   
    showLoader()
    fetchNetworkData()
    hideLoader() 
}</code></pre>

<p>Здесь fetchNetworkData() звучит как долгая операция, которая должна как-то приостановить выполнение loadData(), так как в противном случае вызовется hideLoader() сразу после начала загрузки данных. Как решается такая проблема? Обычно запросы в сеть, либо долгие операции предоставляют механизмы <strong>callback</strong>-ов. Код в таком случае будет выглядеть примерно так:</p>

<pre><code>fetchNetworkData(
        onStart = {
            showLoader()
        },
        onFinish = {
            hideLoader()
        }
)</code></pre>

<p>Таким образом, код, который запускает запрос в сеть, вызовет соответствующие лямбды. </p>

<p>Однако, в мире Андроид делать запрос в сеть нельзя в главном потоке. Иначе вы получите <u>NetworkOnMainThreadException</u>. Главным потоком (UI потоком) считается поток, в котором и запускается приложение. Единственной его ответственностью является <strong>отображение</strong> данных. Любые попытки произвести тяжелые операции приводят к замедлению работы главного потока и ведут к лагам, фризам, ANR (Application Not Responding):</p>

<p style="text-align: center;"><img alt="" height="481" name="image.png" src="https://ucarecdn.com/712f8bcf-34fd-49a3-a7ce-b5f202a1e748/" width="281"></p>

<p> Поэтому необходимо понимать различие потоков и понимать суть работы потоков.</p>



<h1>Callback Hell</h1>

<p>Как же тогда обойти <code>NetworkOnMainThreadException</code> в Андроид? Все просто, делаем запросы в сеть в новом потоке. Создание нового потока вы уже проходили, теперь поговорим про взаимодействие с главным и worker (доп) потоками. Вспомните прошлый пример:</p>

<pre><code>fetchNetworkData(
        onStart = {
            showLoader()
        },
        onFinish = {
            hideLoader()
        }
)</code></pre>

<p>Представим, что fetchNetworkData() внутри создает поток и имеет интерфейсы для взаимодействия с главным потоком. Также мы решили добавить еще один запрос, который используем результат предыдущего запроса и хотим отловить ошибки:</p>

<pre><code>fetchNetworkData(
        onStart = {
            showLoader()
        },
        onFinish = {
            hideLoader()
        },
        onError {
            handleError()
        },
        onComplete { networkData -&gt;
            val networkDetails = networkData.getDetails()
            fetchNewDetails(networkDetails)
        }
)</code></pre>

<p>Какая-то каша получается. Подобным образом работают AsyncTask-и, Retrofit. В RxJava немного по другому выглядело бы:</p>

<pre><code>fetchNetworkData()
.subscribeOn(Schedulers.io())
.observeOn(AndroidSchedulers.mainThread())
.doOnSubscribe(::showLoader)
.doOnTerminate(::hideLoader)
.doOnError(::handleError)
.doOnComplete(::fethcDetails)</code></pre>

<p>Тоже не намного лучше, чем было. Чтобы понимать, что происходит в коде, необходимо лезть в детали fetchDetails, который внутри также может содержать вызов дополнительного метода. Такие конструкции, содержащие много callback-ов, называются Callback Hell. </p>




<h1>Потоки в Андроид</h1>

<p>Когда впервые мы открываем приложение, система запускает процесс, в котором запускается UI поток нашего приложения. В этом потоке инициализируются все компоненты и происходит рендеринг вьюшек для отображения. Помните, что отрисовка вашей вью не должна быть тяжеловесной операцией. Тяжеловесной она будет считаться, если время отрисовки будет больше 16мс (60 fps). В главном потоке запрещается обращаться к запросам в сеть, как и обновлять состояния view из других потоков. То есть результат запроса в сеть должен быть обработан в UI потоке для отображения. Иначе при попытке изменить view из другого потока будет краш.</p>

<p>Для того, чтобы вынести определенную работу в отдельный поток есть разные механизмы в андроид:</p>

<ul>
	<li>Thread. Можем создать поток и передать в него Runnable, который содержит логику для отработки:</li>
</ul>

<pre><code>Thread {// do some work}.start()</code></pre>

<ul>
	<li>AsyncTask. Этот подход был раньше популярен, однако требовал написания большего количества кода и по неосторожности разработчиков был причиной множества утечек памяти. AsyncTask-и сложны в написании и чтении, но самое главное, сейчас помечены как <strong>deprecated</strong>.</li>
	<li>Loaders. Имеют те же недостатки как и AsyncTask, однако были созданы для работы с ЖЦ активити/фрагмента. Также deprecated c API 28. </li>
	<li>RxJava. RxJava больше про асинхронность, нежели многопоточность  Библиотека привносить много неиспользуемого кода, что влияет на build time и размер APK  Сложен в понимании из-за реактивного подхода  Callback Hell.</li>
</ul>



<h1>ThreadPool</h1>

<p>Для того, чтобы работать с потоками, создавать, останавливать и взаимодействовать с потоками,  у нас есть готовый интерфейс <code>ExecutorService</code>.  В основу сервиса исполнения положен интерфейс <strong>Executor</strong>, в котором определен один метод :</p>

<pre><code>void execute(Runnable thread);</code></pre>

<p>При вызове метода <strong>execute</strong> исполняется поток. То есть, метод execute запускает указанный поток на исполнение. Следующий код показывает, как вместо обычного старта потока <code>Thread.start()</code> можно запустить поток с использованием <code>ExecutorService</code> :</p>

<pre>// Вместо следующего кода
Thread {// do some work}.start()

// можно использовать 
var executor: ExecutorService;
..
// init executor
executor.execute(SomeCallable())
result: Future&lt;Any&gt; = executor.submit(SomeCallable())
</pre>

<p>При запуске задач с помощью <code>Executor</code> не требуется прибегать к низкоуровневой поточной функциональности класса <code>Thread</code>, достаточно создать объект типа <code>ExecutorService</code> с нужными свойствами и передать ему на исполнение задачу типа <code>Callable</code>. Впоследствии можно легко просмотреть результат выполнения этой задачи с помощью объекта <code>Future</code>.</p>

<p><code>ExecutorService</code> позволяет создать пул (множество) потоков для работы, которая требует многопоточное выполнение. Вместо того, чтобы ручками создавать потоки и уничтожать потоки при необходимости выполнять работу в новом потоке, механизм <code>ThreadPool</code> используется для переиспользования существующего набора потоков. Таким образом обеспечивается быстрая работа между потоками, ведь каждый раз создавать и уничтожать потоки является довольно тяжелой и долгой операцией. </p>

<p>Работая с <code>ThreadPool</code>, мы настраиваем логику, которую потоки отрабатывают, а не механизмы создания. На примере ниже видно,  как работает <code>ThreadPool</code>:</p>

<p style="text-align: center;"><img alt="" height="308" name="image.png" src="https://ucarecdn.com/aeb15a22-06a5-4b31-8180-6f0ecda6e13f/" width="543"></p>

<p>Когда у нас больше тасков чем потоков в пуле, то <code>ThreadPool</code> ждем освобождения потока для передачи задачи в этот поток.</p>

<p>Ниже представлены методы создания <code>ThreadPool</code> в рамках <code>ExecutorService</code>:</p>

<ul>
	<li><strong>newFixedThreadPool</strong>(int)  - Создает ThreadPool с определенным числом потоков</li>
	<li><strong>newCachedThreadPool</strong>() - Позволяет переиспользовать уже созданные ранее потоки для переиспользования.</li>
	<li><strong>newSingleThreadExecutor</strong>()  - Создает пул из одного потока. </li>
</ul>

<p>Риски использования пула потоков:</p>

<ul>
	<li>Вероятность возникновения <u>взаимной блокировки</u> (<code>Deadlock</code>). Это происходит, когда 2 потока ожидают освобождения ресурсов, которые заняты этими 2 потоками. В итоге оба потока не освобождают ресурс и висят бесконечно.</li>
	<li>Утечка потока. При определенных обстоятельствах (как например <code>Exception</code>) поток может завершиться и количество потоков в пуле уменьшится. Здесь появляется <u>риск торможения</u> работы приложения, либо, в крайнем случае, утечка всех потоков.</li>
	<li>Переполнение ресурсов. Если мы создали чрезмерное количество потоков, которое в действительность и не нужно была, то ресурсы, которые затрачены на создание и настройку взаимодействия потоков были излишними. К примеру, создания пула из 100 потоков для выполнения 5 тасков будет требовать гораздо больше ресурсов, чем нужно, что может привести к <u><code>OutOfMemoryError</code></u>.</li>
</ul>


