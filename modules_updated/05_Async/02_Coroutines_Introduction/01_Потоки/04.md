# ThreadPool

Для того, чтобы работать с потоками, создавать, останавливать и взаимодействовать с потоками,  у нас есть готовый интерфейс `ExecutorService`.  В основу сервиса исполнения положен интерфейс **Executor**, в котором определен один метод :

```
void execute(Runnable thread);
```

![](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)![](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw== "Click and drag to move")

При вызове метода **execute** исполняется поток. То есть, метод execute запускает указанный поток на исполнение. Следующий код показывает, как вместо обычного старта потока `Thread.start()` можно запустить поток с использованием `ExecutorService` :

```
// Вместо следующего кода
Thread {// do some work}.start()

// можно использовать 
var executor: ExecutorService;
..
// init executor
executor.execute(SomeCallable())
result: Future<Any> = executor.submit(SomeCallable())
```

При запуске задач с помощью `Executor` не требуется прибегать к низкоуровневой поточной функциональности класса `Thread`, достаточно создать объект типа `ExecutorService` с нужными свойствами и передать ему на исполнение задачу типа `Callable`. Впоследствии можно легко просмотреть результат выполнения этой задачи с помощью объекта `Future`.

`ExecutorService` позволяет создать пул (множество) потоков для работы, которая требует многопоточное выполнение. Вместо того, чтобы ручками создавать потоки и уничтожать потоки при необходимости выполнять работу в новом потоке, механизм `ThreadPool` используется для переиспользования существующего набора потоков. Таким образом обеспечивается быстрая работа между потоками, ведь каждый раз создавать и уничтожать потоки является довольно тяжелой и долгой операцией.

Работая с `ThreadPool`, мы настраиваем логику, которую потоки отрабатывают, а не механизмы создания. На примере ниже видно,  как работает `ThreadPool`:

![](https://ucarecdn.com/aeb15a22-06a5-4b31-8180-6f0ecda6e13f/)

![](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw== "Click and drag to move")

Когда у нас больше тасков чем потоков в пуле, то `ThreadPool` ждем освобождения потока для передачи задачи в этот поток.

Ниже представлены методы создания `ThreadPool` в рамках `ExecutorService`:

* **newFixedThreadPool**(int)  - Создает ThreadPool с определенным числом потоков
* **newCachedThreadPool**() - Позволяет переиспользовать уже созданные ранее потоки для переиспользования.
* **newSingleThreadExecutor**()  - Создает пул из одного потока.

Риски использования пула потоков:

* Вероятность возникновения взаимной блокировки (`Deadlock`). Это происходит, когда 2 потока ожидают освобождения ресурсов, которые заняты этими 2 потоками. В итоге оба потока не освобождают ресурс и висят бесконечно.
* Утечка потока. При определенных обстоятельствах (как например `Exception`) поток может завершиться и количество потоков в пуле уменьшится. Здесь появляется риск торможения работы приложения, либо, в крайнем случае, утечка всех потоков.
* Переполнение ресурсов. Если мы создали чрезмерное количество потоков, которое в действительность и не нужно была, то ресурсы, которые затрачены на создание и настройку взаимодействия потоков были излишними. К примеру, создания пула из 100 потоков для выполнения 5 тасков будет требовать гораздо больше ресурсов, чем нужно, что может привести к `OutOfMemoryError`.
