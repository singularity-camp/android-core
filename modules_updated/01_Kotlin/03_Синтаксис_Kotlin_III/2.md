<h1>Объекты (object)</h1>

<p>Создаются один раз в области памяти (instance ) и повтороном обращении или создани еще одного объекта, то отдается уже созданный объект. </p>

<p>Например: </p>

<pre><code>object MyObject {
    var age = 10;
}



//Создаем экземпляры
val a = MyObject
a.age = 12 //меняем параметр

val b = MyObject
println(b) // будет 12</code></pre>

<h1>Анонимные объекты и объявление объектов</h1>

<p>Иногда нам необходимо получить экземпляр некоторого класса с незначительной модификацией, желательно без написания нового подкласса. Kotlin справляется с этим с помощью <em>объявления объектов</em> и <em>анонимных объектов</em>.</p>

<p> </p>

<h2>Анонимные объекты (ориг.: <em>Object expressions</em>)</h2>

<p>Объекты анонимных классов, т.е. классов, которые явно не объявлены с помощью <code>class</code>, полезны для одноразового использования. Вы можете объявить их с нуля, наследовать от существующих классов или реализовать интерфейсы. Экземпляры анонимных классов также могут называться <em>анонимными объектами</em>, потому что они объявляются выражением, а не именем.</p>

<p> </p>

<h3>Создание анонимных объектов с нуля</h3>

<p>Анонимный объект начинается с ключевого слова <code>object</code>.</p>

<p>Если вам просто нужен объект, у которого нет нетривиальных супертипов, перечислите его члены в фигурных скобках после <code>object</code>.</p>

<pre><code>val helloWorld = object {
    val hello = "Hello"
    val world = "World!"
    // тип анонимных объектов - Any, поэтому `override` необходим в `toString()`
    override fun toString() = "$hello, $world"
}</code></pre>





<h1>Наследование анонимных объектов от супертипов</h1>

<p>Для того, чтобы создать объект анонимного класса, который наследуется от какого-то типа (типов), укажите этот тип после <code>object</code> и двоеточия (<code>:</code>). Затем реализуйте или переопределите члены этого класса, как если бы вы наследовали от него.</p>

<pre><code>window.addMouseListener(object : MouseAdapter() {
    override fun mouseClicked(e: MouseEvent) { /*...*/ }

    override fun mouseEntered(e: MouseEvent) { /*...*/ }
})
</code></pre>

<p>Если у супертипа есть конструктор, то в него должны быть переданы соответствующие параметры. Множество супертипов может быть указано после двоеточия в виде списка, заполненного через запятую.</p>

<pre><code>open class A(x: Int) {
    public open val y: Int = x
}

interface B { /*...*/ }

val ab: A = object : A(1), B {
    override val y = 15
}</code></pre>



<h1>Использование анонимных объектов в качестве возвращаемых типов значений</h1>

<p>Когда анонимный объект используется в качестве типа local или private, но не встроенного объявления (функции или свойства), все его члены доступны через эту функцию или свойство.</p>

<pre><code>class C {
    private fun getObject() = object {
        val x: String = "x"
    }

    fun printX() {
        println(getObject().x)
    }
}
</code></pre>

<p>Если эта функция или свойство маркированы как встроенные и public или private одновременно, то их тип:</p>

<ul>
	<li><code>Any</code>, если анонимный объект не имеет объявленного супертипа;</li>
	<li>Объявленный супертип анонимного объекта, если существует ровно один такой тип;</li>
	<li>Явно объявленный тип, если существует более одного объявленного супертипа.</li>
</ul>

<p>Во всех этих случаях члены, добавленные в анонимный объект, недоступны. Переопределенные члены доступны, если они объявлены в фактическом типе функции или свойства.</p>

<pre><code>interface A {
    fun funFromA() {}
}
interface B

class C {
    // Возвращаемый тип Any. x недоступен
    fun getObject() = object {
        val x: String = "x"
    }

    // Возвращаемый тип A; x недоступен
    fun getObjectA() = object: A {
        override fun funFromA() {}
        val x: String = "x"
    }

    // Возвращаемый тип B; funFromA() и x недоступны
    fun getObjectB(): B = object: A, B { // требуется явный тип возвращаемого значения
        override fun funFromA() {}
        val x: String = "x"
    }
}</code></pre>





<h1>Доступ к переменным из анонимных объектов</h1>

<p>Код внутри объявленного объекта может обращаться к переменным из окружающей области видимости.</p>

<pre><code>fun countClicks(window: JComponent) {
    var clickCount = 0
    var enterCount = 0

    window.addMouseListener(object : MouseAdapter() {
        override fun mouseClicked(e: MouseEvent) {
            clickCount++
        }

        override fun mouseEntered(e: MouseEvent) {
            enterCount++
        }
    })
    // ...
}</code></pre>