## Устранение противоречий при переопределении

Когда мы объявлем большое количество типов в списке нашего супертипа, может так выйти, что мы допустим более одной реализации одного и того же метода.

```
interface A {
    fun foo() { print("A") }
    fun bar()
}

interface B {
    fun foo() { print("B") }
    fun bar() { print("bar") }
}

class C : A {
    override fun bar() { print("bar") }
}

class D : A, B {
    override fun foo() {
        super<A>.foo()
        super<B>.foo()
    }
  
    override fun bar() {
        super<B>.bar()
    }
}
```

![](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)![](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw== "Click and drag to move")

Оба интерфейса *A* и *B* объявляют функции `foo()` и `bar()`. Оба реализуют `foo()`, но только *B* содержит реализацию `bar()` (`bar()` не отмечен как абстрактный метод в интерфейсе *A*, потому что в интерфейсах это подразумевается по умолчанию, если у функции нет тела). Теперь, если вы унаследуете какой-нибудь класс *C* от интерфейса *A*, вам, очевидно, придётся переопределять метод `bar()`, обеспечивая его реализацию.

Однако если вы унаследуете класс *D* от интерфейсов *A* и *B*, вам надо будет переопределять все методы, которые вы унаследовали от этих интерфейсов, и вам нужно указать, как именно *D* должен их реализовать. Это правило касается как тех методов, у которых имеется только одна реализация (`bar()`), так и тех, у которых есть несколько реализаций (`foo()`).
