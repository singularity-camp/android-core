# Навигация

Когда у нас в приложении имеется больше, чем 1 экран, то у нас назревает вопрос *"А как перейти с одного экрана на другой?"*

Это и является проблемой навигации для нас

По сути, эта проблема будет решаться в зависимости от того, как мы реализуем наши экраны.

Пока что, мы прошли только 2 способа переключаться между экрана. Предлагаю для начала вспомнить предыдущие решения

### 1. Каждый экран это Activity и переходы с помощью startActivity()

---

Самое базовое решение. Такое решение также называется Multiple Activity App

Как можно понять из названия, на каждый экран мы создаем отдельное активити, переходим с помощью startActivity в котором передаем Intent с указанным классом

Для передачи данных мы используем extras в Intent

У такого решения есть свои плюсы и минусы:

**Плюсы:**

1. **Простота и понятность:** Использование множественных активностей может быть простым и интуитивно понятным способом организации кода, особенно для маленьких и средних проектов.
2. **Ясная навигация:** Каждая активность представляет определенный экран или функциональность, что делает навигацию в приложении более прозрачной.
3. **Управление жизненным циклом:** Каждая активность имеет свой собственный жизненный цикл, что может упростить управление ресурсами и памятью.
4. **Разделение ответственностей:** Каждая активность может быть спроектирована для выполнения определенной задачи, что облегчает разделение кода и ответственностей.

**Минусы:**

1. **Усложнение передачи данных:** Передача данных между активностями может потребовать использования `Intent` или других механизмов, что иногда может быть неудобным и приводить к повышенной сложности кода.
2. **Возможные проблемы с производительностью:** Запуск новой активности может быть затратным по ресурсам действием. В некоторых случаях это может сказаться на производительности приложения.
3. **Сложное управление состоянием:** С увеличением количества активностей может усложниться управление состоянием приложения. Например, сохранение и восстановление данных при изменении конфигурации устройства может потребовать дополнительных усилий.
4. **Сложности с переиспользованием кода:** В случае, если активности в приложении имеют схожую функциональность, это может привести к дублированию кода. Разработчик должен аккуратно подходить к архитектуре, чтобы избежать этой проблемы.
5. **Ограничения по проектированию пользовательского интерфейса:** Для определенных макетов пользовательского интерфейса может быть сложно достичь гибкости и масштабируемости с использованием только активностей.
6. Имеем одно Активити, экраны это Фрагменты и перемещаемся между фрагментами с помощью

### 2. Имеем одно Активити, экраны это Фрагменты

---

Такое решение также называется Single Activity App

У такого решения также есть свои плюсы и минусы:

**Плюсы:**

1. **Улучшенное управление жизненным циклом:** Все фрагменты и экраны приложения совместно используют жизненный цикл главной активности, что может упростить управление памятью и ресурсами.
2. **Более эффективное использование памяти:** Загрузка и выгрузка фрагментов в пределах одной активности может привести к более эффективному использованию памяти по сравнению с созданием отдельных активностей для каждого экрана.
3. **Более простое сохранение состояния:** Все состояние активности (включая состояние фрагментов) может быть легко управляемым и сохраняемым при изменении конфигурации устройства, такого как поворот экрана.
4. **Удобство при тестировании:** Тестирование одной активности может быть более простым и эффективным, поскольку все экраны и взаимодействия можно тестировать в едином контексте.

**Минусы:**

1. **Повышенная сложность внутри одной активности:** Как приложение растет по размеру, управление всеми экранами и фрагментами внутри одной активности может стать сложным и требовать хорошей архитектурной организации.
2. **Ограничения по анимациям переходов:** Некоторые анимации переходов между экранами могут быть сложными для реализации в рамках одной активности.
3. **Ограниченность в использовании навигационных паттернов:** Одна активность может быть ограничивающей для определенных навигационных паттернов, таких как боковое меню или вкладки, которые могут быть лучше реализованы с использованием отдельных активностей.
4. **Сложности с обработкой глубоких ссылок (deep links):** Обработка глубоких ссылок, которые напрямую открывают определенный экран, может быть сложной задачей в структуре с одной активностью.
5. **Ограничения для некоторых архитектурных паттернов:** Некоторые разработчики предпочитают использовать определенные архитектурные паттерны (например, Clean Architecture), которые могут требовать более гибкой структуры, чем предоставляет подход с одной активностью.

На данный момент для перемещения между фрагментами мы использовали FragmentManager и FragmentTransactions

Этот подход хорош тем, что мы имеем полный контроль над процессом, но он может быть также сложен в реализации

Для решения этой проблемы Google сделала своё решение в виде **Navigation Component**


## Android Navigation Component


**Navigation Component** - это часть Android Jetpack, предоставляющая унифицированный и удобный способ управления навигацией в приложениях Android. Он вводит новый компонент - Navigation Graph, представляющий граф экранов (фрагментов или активностей) и направления между ними. Navigation Component предоставляет декларативный способ определения навигации, что облегчает понимание и поддержку структуры приложения.

**Плюсы использования Navigation Component:**

1. **Декларативный подход:** Navigation Component предоставляет декларативный способ определения структуры навигации, что делает код более читаемым и поддерживаемым.
2. **Интеграция с Android Studio:** Navigation Component интегрирован в Android Studio, предоставляя визуальный редактор навигационных графов, что упрощает проектирование и понимание структуры приложения.
3. **Упрощенное управление фрагментами и активностями:** Navigation Component управляет жизненным циклом фрагментов и активностей, что облегчает задачи, связанные с их созданием, уничтожением и сохранением состояния.
4. **Легкость внедрения анимаций:** Navigation Component предоставляет простой способ добавления анимаций при переходах между экранами.
5. **Безопасная передача аргументов:** Navigation Component включает в себя Safe Args - механизм для безопасной передачи аргументов между экранами с автоматической генерацией классов, что предотвращает ошибки связанные с передачей данных.
6. **Интеграция с глубокими и динамическими ссылками:** Navigation Component облегчает обработку глубоких и динамических ссылок, что упрощает реализацию функциональности перехода к определенному экрану извне приложения.
7. **Управление обратным стеком (Back Stack):** Navigation Component предоставляет гибкий механизм управления обратным стеком, что упрощает управление навигацией назад.
8. **Поддержка Single Activity:** Navigation Component хорошо интегрируется с подходом Single Activity, обеспечивая удобство управления фрагментами внутри одной активности.
