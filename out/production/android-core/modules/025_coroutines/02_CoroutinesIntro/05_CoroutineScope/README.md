# Coroutine Scope

Корутины (последовательные/параллельные) выполняются асинхронно и завершаются в зависимости от того, какой код выполнятся внутри корутины. В таких случаях код может продолжать выполняться, даже если вызывающий корутину код уже завершился. Если корутину не остановить при остановки вызывающей стороны, это может привести к нежелательным последствиям (утечке памяти, например).

Для такого контроля жизненного цикла корутин был придуман **Coroutine Scope**.Он позволяет контролировать жизненный цикл корутины и всех **suspend** методов внутри, в том числе дочерних корутин. Мы связываем выполнение какой-то корутины с ЖЦ этого scope и при надобности можем остановить выполнение всех корутин в рамках этого скоупа.

```
fun main(args: Array<String>) {
    val job = GlobalScope.launch {
        delay(1000L)
        println("After 1s")
        delay(1000L)
        println("After 2s")
        delay(1000L)
        println("After 3s")
        delay(1000L)
        println("After 4s")
    }

    Thread.sleep(2500L)
    println("Cancelling after 2.5s")
    job.cancel()
    Thread.sleep(2000L)
}
```

В примере выше создается корутина с `GlobalScope`, результат в виде `Job` записывается в переменную. После 2.5 секунд останавливаем job, и как видно из вывода на консоли, корутина останавливается.

`GlobalScope` сам по себе не привязан ни к чему. Его необходимо останавливать ручками, из-за чего не рекомендуется к использованию. В будущем уроке мы напишем свой `Scope`, который будет останавливаться автоматически при закрытии экрана.

Обратите внимание в коде выше мы не используем `runBlocking`. Текущий поток останавливается с помощью Thread.sleep, после чего останавливается корутина и за последние 2 секунд консоль не отобразила вывод из под корутины.
